<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PrimerParcial</title>
    <link rel="stylesheet" href="normalize.css">
    <link rel="stylesheet" href="estiloindex.css">
    <link rel="stylesheet" href="estilos.css">
    <link rel="stylesheet" href="deplegable.css">
</head>

<link rel="stylesheet" href="normalize.css">
<link rel="stylesheet" href="estiloindex.css">
<link rel="stylesheet" href="estilos.css">
<link rel="stylesheet" href="deplegable.css">
</head>

<nav class="nav">

    <div class="nav__container">

        <a href="Index.html" class="back"><h1 class="nav__title">PRIMER PARCIAL</h1></a>

        <a href="#menu" class="nav__menu">
            <img src="./assets/menu.svg" class="nav__icon">
        </a>

        <a href="#" class="nav__menu nav__menu--second">
            <img src="./assets/close.svg" class="nav__icon ">
        </a>

        <ul class="dropdown" id="menu">

            <li class="dropdown__list">
                <a href="Index.html" class="dropdown__link">
                    <img src="./assets/house.svg" class="dropdown__icon">
                    <span class="dropdown__span">Inicio</span>
                </a>
            </li>

            <li class="dropdown__list">
                <a href="#" class="dropdown__link">
                    <img src="./assets/projects.svg" class="dropdown__icon">
                    <span class="dropdown__span">Primer Parcial</span>
                    <img src="./assets/down.svg" class="dropdown__arrow">

                    <input type="checkbox" class="dropdown__check">
                </a>

                <div class="dropdown__content">

                    <ul class="dropdown__sub">

                        <li class="dropdown__li">
                            <a href="primerParcial.html.html" class="dropdown__anchor">Historia de la Computación Definiciones</a>
                        </li>
                        <li class="dropdown__li">
                           <a href="" class="dropdown__anchor">EVOLUCION DE LOS SISTEMAS DE CALCULO</a>
                       </li>
                       <li class="dropdown__li">
                        <a href="" class="dropdown__anchor">Calculadora mecánica 1</a>
                        </li>
                           <li class="dropdown__li">
                        <a href="" class="dropdown__anchor">Calcuadoras Mecánicas 2</a>
                      </li>
                        <li class="dropdown__li">
                      <a href="" class="dropdown__anchor">Calculadora Mecánica 3</a>
                       </li>
                       <li class="dropdown__li">
                        <a href="" class="dropdown__anchor">Calculadora Mecánica 3</a>
                         </li>
                         <li class="dropdown__li">
                         <a href="#compu1" class="dropdown__anchor">Las Primeras Computadoras 1</a>
                         </li>
                         <li class="dropdown__li">
                        <a href="" class="dropdown__anchor">Las Primeras Computadoras 2</a>
                         </li>
                         <li class="dropdown__li">
                        <a href="" class="dropdown__anchor">Las Primeras Computadoras 3</a>
                        </li>
                     <li class="dropdown__li">
                        <a href="" class="dropdown__anchor">Babbage VS Neumann</a>
                        </li>
                        <li class="dropdown__li">
                     <a href="" class="dropdown__anchor">Generaciones</a>
                        </li>
                        <li class="dropdown__li">
                     <a href="" class="dropdown__anchor">Diferencias entre Macro computadoras y Súper Computadoras</a>
                        </li>
                        <li class="dropdown__li">
                        <a href="" class="dropdown__anchor">Conceptos Básicos</a>
                     </li>   
                        <li class="dropdown__li">
                            <a href="#arqui" class="dropdown__anchor">arquitectura de computadoras</a>
                        </li>
                        <li class="dropdown__li">
                            <a href="#intro" class="dropdown__anchor">Sistemas Operativos</a>
                        </li>
                        <li class="dropdown__li">
                           <a href="" class="dropdown__anchor">Estructuración de Sistemas Operativos</a>
                           </li>
                           <li class="dropdown__li">
                              <a href="" class="dropdown__anchor">Control de Procesos</a>
                              </li>
                              <li class="dropdown__li">
                              <a href="" class="dropdown__anchor">Modelo de Estados</a>
                             </li>
                             <li class="dropdown__li">
                             <a href="" class="dropdown__anchor">Estados de un Proceso</a>
                              </li>
                             <li class="dropdown__li">
                              <a href="" class="dropdown__anchor">Todo sobre LINUX</a>
                              </li>
                              <li class="dropdown__li">
                              <a href="" class="dropdown__anchor">Ficheros y perfiles</a>
                           </li>
   


                    </ul>

                </div>
            </li>

            <li class="dropdown__list">
                <a href="#" class="dropdown__link">
                    <img src="./assets/projects.svg" class="dropdown__icon">
                    <span class="dropdown__span">Segundo Parcial</span>
                    <img src="./assets/down.svg" class="dropdown__arrow">
                    <input type="checkbox" class="dropdown__check">
                </a>

                <div class="dropdown__content">

                    <ul class="dropdown__sub">

                        <li class="dropdown__li">
                            <a href="segundoParcial.html" class="dropdown__anchor">Bases de Datos</a>
                        </li>
                        <li class="dropdown__li">
                           <a href="segundoParcial.html" class="dropdown__anchor">Bases de datos relacionales</a>
                       </li>
                       <li class="dropdown__li">
                        <a href="segundoParcial.html" class="dropdown__anchor">Relaciones de base de datos</a>
                    </li>
                    <li class="dropdown__li">
                     <a href="segundoParcial.html" class="dropdown__anchor">Arquitectura para Sistemas de Base de Datos</a>
                 </li>
                 <li class="dropdown__li">
                  <a href="segundoParcial.html" class="dropdown__anchor">Administrador de Base de Datos</a>
              </li>
              <li class="dropdown__li">
               <a href="segundoParcial.html" class="dropdown__anchor">Modelo Entidad Relación</a>
          
                        <li class="dropdown__li">
                            <a href="segundoParcial.html" class="dropdown__anchor">Normalización</a>
                        </li>
                     </li>
                     <li class="dropdown__li">
                      <a href="segundoParcial.html" class="dropdown__anchor">Formas Normales</a>
                  </li>
                  <li class="dropdown__li">
                   <a href="segundoParcial.html" class="dropdown__anchor">Comunicaciones, redes y comunicación de datos</a>
               </li>
               <li class="dropdown__li">
                <a href="segundoParcial.html" class="dropdown__anchor">Clasificación de Redes por su área geográfica</a>
            </li>
                        <li class="dropdown__li">
                            <a href="segundoParcial.html" class="dropdown__anchor">Modelo de Redes</a>
                        </li>
                      

                    </ul>

                </div>
            </li>

            <li class="dropdown__list">
                <a href="#" class="dropdown__link">
                    <img src="./assets/projects.svg" class="dropdown__icon">
                    <span class="dropdown__span">Examen Final</span>
                    <img src="./assets/down.svg" class="dropdown__arrow">
                    <input type="checkbox" class="dropdown__check">
                </a>
                <div class="dropdown__content">

                    <ul class="dropdown__sub">

                        <li class="dropdown__li">
                            <a href="tercerParcial.html" class="dropdown__anchor">Introducción al Desarrollo Web</a>
                        </li>
                        <li class="dropdown__li">
                           <a href="tercerParcial.html" class="dropdown__anchor">La web</a>
                       </li>
                       <li class="dropdown__li">
                        <a href="tercerParcial.html" class="dropdown__anchor">Lenguaje HTML</a>
                    </li>
                        <li class="dropdown__li">
                            <a href="tercerParcial.html" class="dropdown__anchor">Fundamentos de HTML</a>
                        </li>
                        <li class="dropdown__li">
                           <a href="tercerParcial.html" class="dropdown__anchor">Programación WEB</a>
                       </li>
                        <li class="dropdown__li">
                            <a href="tercerParcial.html" class="dropdown__anchor">Estructura de una página WEB</a>
                        </li>
                        <li class="dropdown__li">
                           <a href="tercerParcial.html" class="dropdown__anchor">Formularios HTML</a>
                       </li>
                      

                    </ul>

                </div>

            </li>

        </ul>

    </div>

</nav>


<body>
    <ul>
        <h2 id="#Historia">HISTORIA DE LA COMPUTACION DEFINICIONES</h2>
            
        <li>Informática</li>
        <p>
         (Según la Real Academia Española de la Lengua) Es el conjunto de conocimientos
         ientíficos y técnicos para hacer posible el tratamiento automático de la información por medio de computadoras electrónicas.
        </p>
        <li>Computaodra u ordenador</li>
        <p>
         Es una máquina electrónica capaz de aceptar unos datos de entrada,
         efectuar con ellos una operaciones aritméticas y lógicas, y proporcionar la información resultante a través de un medio de salida.
        </p>
        <li>Calculadora</li>
        <p>
         (acepción actual) Es una máquina capaz de efectuar operaciones aritméticas bajo el control directo del usuario.
        </p>
        <li>Datos</li>
        <p>
         Son conjuntos de símbolos utilizados para expresar o representar un valor numérico, un hecho, un objeto o una idea, codificada en la forma adecuada para ser objeto de tratamiento por medio de una computadora.
        </p>
        <li>Información</li>
        <p>
         Datos tratados y organizados, con significado desde el punto de vista del usuario.
        </p>
    </ul>

    <h2 id="Evolucion">EVOLUCION DE LOS SISTEMAS DE CALCULO</h2>
    <ul>
        <li>Ábaco</li>
        <p>
         Serie de alambres paralelos, sujetos por los extremos en un armazón rectangular, sobre los que se pueden desplazar una serie de bolas o fichas.
        </p>
        <div>
         <img src="imgPrimer/2 1.png" alt="">
        </div>
    </ul>
    <h2 id="calculadora">CALCULADORA MECANICA 1</h2>
    <ul>
        <li>La Calculadora de Sckickard</li>
        <p>
         En 1623 Wilhelm Sckickard construye la primera máquina de calcular.
        </p>
        <li>La Pascalina</li>
        <p>
         1.642 Blaise Pascal. Conjunto de discos dentados, cada uno de los cuales tiene 10
         divisiones, que representaban un dígito. Es capaz de realizar sumas y restas.
        </p>
        <li>La Calculadora Universal</li>
        <p>
         1694 Gottfried W. Leibniz. Perfecciona la máquina de Pascal añadiéndole la
         multiplicación y división.
        </p>
        <li>La Lógica Matemática</li>
        <p>
         George Boole (1815-1864), es el fundador de la teoría de la lógica matemática.
        </p>
    </ul>
    <div>
      <img src="imgPrimer/3 1.png" alt="">
      <img src="imgPrimer/3 2.png" alt="">
    </div>

    <h2 id="calculadora2">CALCULADORAS MECANICAS 2</h2>
    <ul>
        <li>El Padre de la Computadora</li>
        <p>
         Se considera a Charles Babbage (1791- 1871), como el padre de los sistemas
         actuales de computación. A Charles Babbage se le atribuye el desarrollo de dos
         máquinas de cálculo:
        </p>
        <li>La Máquina Diferencial</li>
        <p>
         (1821) capaz de calcular polinomios de sexto grado y
         tabular mecánicamente hasta veinte cifras y ocho decimales
        </p>
        <li>La Máquina Analítica</li>
        <p>
         (1833) sistema mecánico precursor de la computadora
         del siglo XX. Disponía de:
        </p>
        <ul>
         <li>Dispositivos de entrada/salida de datos (tarjetas perforadas)</li>
         <li>Unidad de memoria</li>
         <li>Dispositivo de cálculo llamado "Mill" (Unidad Aritmética)</li>
         <li>Mecanismo de barras y palancas que accionaba el
            conjunto (Unidad de Control), conducido por un programa codificado sobre
            tarjetas perforadas.
            </li>

        </ul>
     </ul>
     <div>
      <img src="imgPrimer/4 1.png" alt="">
     </div>

     <h2 id="calculadora3">CALCULADORA MECANICA 3</h2>
     <ul>
        <li>La máquina de Tabular</li>
        <p>
         En 1890 Herman Hollerith (1860-1929), inventó su máquina tabuladora que utilizaba corriente 
         eléctrica para detectar los agujeros que estaban perforados y así hizo registrar la información
         en tarjetas, y el tiempo total del proceso se redujo. Sistema de automatización del censo.
        </p>
     </ul>

     <div>
      <img src="imgPrimer/5 1.png" alt="">
     </div>
     <h2 id="compu1">LAS PRIMERAS COMPUTADORAS 1</h2>
     <ul>
        <li>La Computadora Electromecánica Z-1 (1935)</li>
        <p>
         Konrad Zuse en Berlín desarrolló su computadora Z-1 Mark I Computer (ASCC) Automatic Sequence Controller 
         Calculator (1944) Desde 1937 hasta 1944, IBM patrocinó el proyecto del Dr. Howard H. Aiken, profesor de la 
         universidad de Harvard. En 1944 finalizó su objetivo con el nombre de Mark I
        </p>
     </ul>

     <div>
      <img src="imgPrimer/6 1.png" alt="">
     </div>

     <h2 id="compu2">LAS PRIMERAS COMPUTADORAS 2</h2>
     <ul>
        <li>La Computadora Electrónica</li>
        <p>
         ABC (Atanasoff Berry Computer) (1936/37) John Vicent Atanasoff y Clifford Berry. Principios de las primeras computadoras.
        </p>
        <li>ENIAC </li>
        <p>
         (Electronic Numerical Integrator and Computer) (1946) Construido en la universidad de Pennsylvania, por John W. Mauchly y John Presper Eckert.
        </p>
     </ul>

     <div>
      <img src="imgPrimer/7 1.png" alt="">
      <img src="imgPrimer/7 2.png" alt="">
     </div>
     <h2 id="compu3">LAS PRIMERAS COMPUTADORAS 3</h2>
     <ul>
        <li>John Von Neumann (1903-1957)</li>
        <p>
         1.946 "First Draft of a Report on to Edvac“ Principios ordenadores del tipo Von Neumann:
        </p>
        <ul>
         <li>Concepto de numeración codificada</li>
         <li>Almacenamiento del programa en memoria</li>
         <li>Perfeccionamiento de la ruptura de secuencia</li>
        </ul>
        <li>EDSAC (1.949)</li>
        <p>
         M. Wikes, de la Universidad de Cambridge
        </p>
        <li>UNIVAC (1.951)</li>
        <p>
         Eckert y Mauchly, primera computadora adquirida con
         fines lucrativos.

        </p>
     </ul>

     <div>
      <img src="imgPrimer/10 8.png" alt="">
     </div>
     <h2 id="babbage">Babbage VS Neumann</h2>
     <div>
      <img src="imgPrimer/9 1.png" alt="">
     </div>
     <h2 id="generaciones">Generaciones</h2>
     <ul>
        <li>Primera generacion</li>
        <ul>
         <li>Tecnología empleada: Válvulas de vacío</li>
         <li>Uso: Científico y militar</li>
         <li>Programación:</li>
         <p>Modificando directamente los valores de los circuitos de la máquina. No existían los lenguajes de programación, si siquiera ensamblador</p>
         <li>Ordenadores caros</li>
         <p>debido a la corta vida de las válvulas de vacío y al gran calentamiento, asi como al gran consumo de energía eléctrica.</p>
         <li>Ordenadores lentos</li>
         <li>Capacidad de almacenamiento muy pequeña.</li>
         <li>Incapacidad de ejecutar más de una tarea a la vez.</li>
         <p>Algunas de las realizaciones son: UNIVAC, EDSAC, EDVAC, ORDAC, ILLIAC, MANIAC, JHOANIAK, WEIZAK.</p>

        </ul>
        <div>
        
         <img src="imgPrimer/10 2.png" alt="">
         <img src="imgPrimer/10 3.png" alt="">
         <img src="imgPrimer/10 4.png" alt="">

        </div>
        <li>Segunda Generacion</li>
        <ul>
         <li>Tecnología empleada: Transmisor</li>
         <li>Disponía ya de una progrmación previa, de un Sistempa Operativo, capaz de interpretar instrucciones escritas en lenguajes de programación como COBOL
            o FORTRAN.
         </li>
         <li>Comienza el desarrollo de periféricos de E/S (impresoras) y los Lenguajes de alto nivel (y el ensamblador).</li>
         <li>El modo de trabajo era generalmente el sistema por lotes</li>
         <li>Aumento de la velocidad en el cálculo</li>
         <li>Reducción de tamaño</li>
         <li>Reducción del consumo a energía y potencia disipada.</li>
         <li>Tiempo de vida media del transistor superior a la válvula</li>
         <li>Abaratamiento</li>
         <p>Algunas de las realizaciones son: Sperry Rand 1007, IBM 700, IBM 1400, 1700.</p>
        </ul>
        <div>

         <img src="imgPrimer/10 6.png" alt="">
         <img src="imgPrimer/10 7.png" alt="">
         <img src="imgPrimer/10 8.png" alt="">
        </div>
        <li>Tercera Generación</li>
        <ul>
         <li>Tecnología empleada: Circuito integrado (lámina de silicio embutida en plástico). Se utilizan materiales semiconductores en lugar de los núcleos de 
            ferrita en la construcción de memorias.
         </li>
         <li>Se mejoran los lenguajes de programación y empezaron a aparecer programas comerciales, con lo que un usuario no tenía que programar sus aplicaciones.</li>
         <li>Capacidad de multiprogramación, con lo cual los ordenadores son capaces de ejecutar varias tareas al mismo tiempo.</li>
         <li>Aumento en la velocidad de cálculo</li>
         <li>Tamaño disminuye</li>
         <p>Algunas de las realizaciones son: IBM System/360, GE 600, PDP-11.</p>
        </ul>
        <div>
      
         <img src="imgPrimer/10 10.png" alt="">
         <img src="imgPrimer/10 11.png" alt="">
         <img src="imgPrimer/10 12.png" alt="">
         <img src="imgPrimer/10 13.png" alt="">
        </div>
        <li>Cuarta Generación</li>
        <ul>
         <li>Tecnología empleada: Circuitos de alta escala de integración Microprocesadores.</li>
         <li>Es el producto de una serie de avances tanto en el hardware, y su tecnología de fabricación, como en el software y sus posibilidades de aplicación</li>
         <ul>
            <li>Nuevas tecnologías de fabricación de semiconductres que conducen a velocidades de transmision cada vez mayores y mayor capacidad de 
               almacenamiento.
            </li>
            <li>Aparición de paquetes software, que obedecen a nuevas concepciones y situaciones específicas: base de datos, diseño asistido, tratamiento de texto...</li>
            <li>Nuevas memorias de almacenamiento: Tecnologías Winchester, y burbujas magnéticas</li>
            <li>Aparición de los ordenadores personales</li>
            <li>Más lenguajes de alto nivel y herramientas informáticas</li>
            <li>Desarrollo de periféricos inteligentes: descargan de trabajo a la CPU.</li>
            <li>Hacia mediados de los 80, comienza el desarrollo de redes de computadoras personales que corren sistemas operativos en red y sistemas operativos distribuidos.</li>
         </ul>
        </ul>
        <div>
         
         <img src="imgPrimer/10 15.png" alt="">
         <img src="imgPrimer/10 16.png" alt="">
        </div>
        <li>Quinta Generación</li>
        <ul>
         <li>Arquitectura es diferente a la propuesta por Von Neumann</li>
         <li>Ordenadores inferentes</li>
         <li>Ordenador óptico</li>
         <li>Máqinas neuronales</li>
         <li>Sistemas informáticos distribuidos</li>
        </ul>
        <div>
        
         <img src="imgPrimer/10 18.png" alt="">
         <img src="imgPrimer/10 19.png" alt="">
        </div>
        <br>
        <li>Generaciones ordenador Personal</li>
        <ul>
         <li>Años 70, primer microprocesador, el INTEL 4004, posibilidad de construcción de un ordenador utilizable por un solo usuario.</li>
         <li>1977, S. Wozniak y S. Jobs, fundaron una empresa llamada Apple.</li>
         <li>1981, IBM PC (Personal computer)</li>
         <li>Evolución tanto en el microprocesador utilizado (8088, 8086, 50286, 80386, 80483, Pentium y el sistema operativo(UNIX para PC, el OS/2
         de IBM y el Windows-NT, Win95, Win98 de Microsoft). 
         </li>
         <li>Mediados de los 80, comineza el desarrollo de redes de computadoras personales</li>
        </ul>
        <div>
       
         <img src="imgPrimer/10 21.png" alt="">
        </div>
        <li>Sexta Generación</li>
        <p>
         (1990- ?) Se caracteriza por la evolución de las comunicaciones a la par de la tecnología.
          La miniaturización de componentes en las máquinas, y su reducción en costo conllevan a 
          sistemas de alta capacidad. Cuentan con arquitecturas combinadas Paralelo / Vectorial,
           con cientos de microprocesadores vectoriales trabajando al mismo tiempo; se han creado 
           computadoras capaces de realizar más de un millón de millones de operaciones aritméticas 
           de punto flotante por segundo (teraflops).El uso de redes se hace común, con grandes 
           velocidades y la integración de servicios de video de calidad, voz y otros datos multimedia en
            tiempo
           real.
           
        </p>
        <div>
        <img src="imgPrimer/11 1.png" alt="">
        <img src="imgPrimer/11 2.png" alt="">
        </div>
     </ul>
     <h2>CLASIFICACIÓN DE COMPUTADORAS</h2>
     <div>
      <img src="imgPrimer/12 1.png" alt="">
      <br>
      <img src="imgPrimer/12 2.png" alt="">
      <br>
      <img src="imgPrimer/12 3.png" alt="">
      <br>
      <img src="imgPrimer/12 4.png" alt="">
      <br>
      <img src="imgPrimer/12 5. png" alt="">
      <br>
      <img src="imgPrimer/12 6.png" alt="">
     </div>
     <br>
     <h2 id="diferencias">Diferencias</h2>
     <h3>Macro computadoras</h3>
     <p>Son más poderosas, soportan más programas simultáneos.</p>
     <ul>
      <li>Problemas limitados - Fiabilidad.</li>
      <li>Tienen de uno a varias docenas de procesadores.</li>
      <li>Su aplicación: administración publica.</li>
      <li>Cálculos simples con bases de datos.</li>
     </ul>
     <h3>Super computadoras</h3>
     <p>Pueden uejecutar un solo programa más rápdio.</p>
     <ul>
      <li>Problemas limitados - Velocidad</li>
      <li>Trabajan con paralelismo masivo</li>
      <li>Su aplicación: la ciencia y el ejército</li>
      <li>Cálculos complicados con la memoria</li>
     </ul>
     <h3>Mini Computadoras</h3>
     <ul>
      <li>Es de nivel medio</li>
      <li>Realiza cálculos complejos</li>
      <li>Gestiona gran cantidad de usuarios conectados</li>
      <li>Es una versión más pequeña que la macro computadora</li>
      <li>Utilidad</li>
     </ul>
     <div>
      <img src="imgPrimer/13 1.png" alt="">

     </div>
     <h3>Microcomputador</h3>
     <ul>
      <li>Dispostivio electrónico</li>
      <li>Microprocesador CPU</li>
      <li>Herramienta de trabajo y entretenimiento</li>
      <li>Circuito integrado</li>
      <li>Velocidad</li>
      <li>Almacenamiento</li>
      <li>Miniaturización</li>
     </ul>
     <div>
      <img src="imgPrimer/13 2.png" alt="">

     </div>
     <br>
     <h3>Según su aplicación:</h3>
     <ul>
      <li>Computadoras de aplicación general</li>
      <li>Computadoras de aplicación específica o especial</li>
     </ul>
     <h2>Siguiente Generación de Computadoras</h2>
     <p>Otras alternativas como:</p>
     <ul>
      <li>Computación Molecular</li>
      <li>Computación Óptica</li>
      <li>Computación Cuántica</li>
     </ul>
     <h3>El futuro cercano:</h3>
     <div>
      <img src="imgPrimer/14 1.png" alt="">
      <img src="imgPrimer/14 2.png" alt="">
     </div>
     <h2 id="conceptos">CONCEPTOS BASICOS</h2>
     <ul>
        <li>SOFTWARE</li>
      <p>
         Es todo el conjunto intangible de datos y programas de la computadora.
      </p>
      <h3>Clasificación del Software:</h3>
      <h4>Sistemas Operativos</h4>
      <p>
         El sistema operativo es el gestor y organizador de todas las actividades que realiza
      la computadora. Marca las pautas según las cuales se intercambia información entre
        memoria central y la externa, y determina las operaciones elementales que puede
      realizar el procesador.
      </p>
      <h4>Lenguajes de Programación</h4>
      <p>
         Mediante los programas se indica a la computadora que tarea debe realizar y cómo
      efectuarla , pero para ello es preciso introducir estas órdenes en un lenguaje que el
      sistema pueda entender. En principio, el ordenador sólo entiende las instrucciones en
      código máquina, es decir ,el específico de la computadora. Sin embargo, a partir de
      éstos se elaboran los llamados lenguajes de alto y bajo nivel.

      </p>

      <h4>Software de aplicaciones</h4>
      <p>
         El software de aplicación esta diseñado y escrito para realizar tareas específicas
      personales, empresariales o científicas como el procesamiento de nóminas, la
      administración de los recursos humanos o el control de inventarios. Todas éstas
      aplicaciones procesan datos (recepción de materiales) y generan información
      (registros de nómina). para el usuario.

      </p>
      <div>
        <img src="imgPrimer/17 1.png" alt=""> 
        <img src="imgPrimer/17 2.png" alt="">
        <img src="imgPrimer/17 3.png" alt="">
        <img src="imgPrimer/17 4.png" alt="">
        <img src="imgPrimer/17 5.png" alt="">
      </div>
        <li>HARDWARE</li>
        <p>
         Los componentes y dispositivos del Hardware se dividen en:
        </p>
        <ul>
         <li>Hardware Básico y Hardware Complementario.</li>
         <li>El Hardware Básico: son las piezas fundamentales e imprescindibles para que la computadora 
            funcione como son: Placa base, monitor, teclado y ratón.</li>
         <li>El Hardware Complementario: son todos aquellos dispositivos adicionales no esenciales como 
            pueden ser: impresora, escáner, cámara de vídeo digital, webcam, etc.</li>
        </ul>

        <div>
         <img src="imgPrimer/18 1.png" alt="">
         <img src="imgPrimer/18 2.png" alt="">
        </div>

        <h4>Grupo de Hardware</h4>
        <p>Según sus funciones, los componentes y dispositivos del hardware se dividen en varios grupos y en el siguiente orden:</p>
        <ul>
         <li>Dispositivos de Entrada</li>
         <li>Chipset (Circuito Integrado Auxiliar)</li>
         <li>Unidad Central de Procesamiento (CPU)</li>
         <li>Unidad de Control</li>
         <li>Unidad Aritmético-Lógica</li>
         <li>Unidad de Almacenamiento</li>
         <li>Memoria Principal o Primaria (RAM – ROM)</li>
         <li>Memoria Secundaria o Auxiliar (Disco Duro, Flexible, etc.)</li>
         <li>Dispositivos de Salida</li>
        </ul>

        <li>FIRMWARE</li>
        <p>El firmware es un bloque de instrucciones de programa para propósitos específicos, grabado en una memoria de tipo no volátil (ROM, EEPROM, 
         flash, etc), que establece la lógica de más bajo nivel que controla los circuitos electrónicos de un dispositivo de cualquier tipo.
         Al estar integrado en la electrónica del dispositivo es en parte hardware, pero también es software, ya que proporciona lógica y se
          dispone en algún tipo de lenguaje de programación. Funcionalmente, el firmware es el intermediario (interfaz) entre las órdenes externas que recibe el dispositivo y su electrónica
         </p>

         <div>
            <img src="imgPrimer/20 1.png" alt="">
            <img src="imgPrimer/20 2.png" alt="">
            <img src="imgPrimer/20 3.png" alt="">
         </div>
        <li>MIDDLEWARE</li>
        <p>
         Es un software que asiste a una aplicación para interactuar o comunicarse con otras aplicaciones, software, redes, hardware y/o sistemas operativos. Éste simplifica el trabajo de los 
         programadores en la compleja tarea de generar las conexiones que son necesarias en los sistemas distribuidos. De esta forma se provee una solución que mejora la calidad de servicio, 
         seguridad, envío de mensajes, directorio de servicio
        </p>

        <div>
         <img src="imgPrimer/21 1.png" alt="">
        </div>

        <li>CONECTIVIDAD</li>
         <p>
            es la capacidad de un dispositivo (ordenador personal, periférico, PDA, móvil, robot, electrodoméstico, automóvil, etc.) de poder ser conectado (generalmente a un ordenador personal 
            u otro dispositivo electrónico) sin la necesidad de un ordenador, es decir en forma autónoma. Asimismo es el grado de conexión entre entidades sociales, gubernamentales y de cualquier 
            índole entre sí
         </p>
         <ul>
            <li>Bluetooth</li>
            <li>Red de computadoras</li>
            <li>WI-FI</li>
            <li>WIMAX</li>
         </ul>

         <div>
         <img src="imgPrimer/22 1.png" alt="">
         <img src="imgPrimer/22 2.png" alt="">
         <img src="imgPrimer/22 3.png" alt="">
         </div>

        <li>BIT</li>
        <p>
         Bit es el acrónimo Binary digit. (dígito binario). Un bit es un dígito del sistema de numeración binario.
        </p>

        <ul>
         <li>Mientras que en el sistema de numeración decimal se usan diez dígitos, en el binario se usan sólo dos dígitos, 
            el 0 y el 1. Un bit o dígito binario puede representar uno de esos dos valores, 0 ó 1.</li>
            <li>
               Se puede imaginar un bit, como una bombilla que puede estar en uno de los siguientes dos estados:
            </li>
        </ul>
        <p><b>El bit es la unidad mínima de información empleada en informática, en cualuiqe dispositivo
         digital, o en la teoría de la información.
        </b></p>
        <div>
         <img src="imgPrimer/23 1.png" alt="">
        </div>

        <li>BYTE</li>
        <p>
         Un byte se define como la unidad básica de almacenamiento de la información, habitualmente compuesto por 8 bits (unidad mínima de 
         información que puede ser 1 -encendido- o 0 -apagado).
        </p>

        <p>
         A partir del byte surge el Kb (kilobyte), el Mb (megabyte), el Gb (gigabyte), etc. que representan distintas potencias de 2, 
         puesto que se trabaja en sistema binario. Así el Kb son 2 elevado a 10 (1024), el Mb 2 elevado a 20 (1048576) y así sucesivamente.
        </p>

        <p>
         La notación del Sistema Internacional de Unidades utiliza el sistema decimal y trabaja sobre potencias de 10. Un Kb serían 10 
         elevado a 3 (1000), un Mb 10 elevado a 6 (1000000), etc.
        </p>
<br>
<br>
        <li>CUANTIFICACIÓN DE BITS A BYTES</li>
        <div>
         <img src="imgPrimer/25 1.png" alt="">
        
         <img src="imgPrimer/25 3.png" alt="">
        </div>
        <table>
        <tr>
         <th>Nombre </th>
         <th>Abrev. </th>
         <th>Factor Binario </th>
         <th>Tamaño en el SI</th>
        </tr>
        <tr>
         <td>bytes</td>
         <td>B</td>
         <td>2<sup>10</sup>=1024</td>
         <td>10<sup>0</sup>=1</td>
        </tr>
        <tr>
         <td>kilo</td>
         <td>k</td>
         <td>2<sup>0</sup>=1</td>
         <td>10<sup>3</sup>=1000</td>
        </tr>
        <tr>
         <td>mega</td>
         <td>M</td>
         <td>2<sup>20</sup>=1 048 576</td>
         <td>10<sup>6</sup>=1 000 000</td>
        </tr>
        <tr>
         <td>giga</td>
         <td>G</td>
         <td>2<sup>30</sup>=1 073 741 824</td>
         <td>10<sup>9</sup>=1 000 000 000</td>
        </tr>
        <tr>
         <td>tera</td>
         <td>T</td>
         <td>2<sup>40</sup>=1 099 511 627 776</td>
         <td>10<sup>12</sup>=1 000 000 000 000</td>
        </tr>
        <tr>
         <td>peta</td>
         <td>P</td>
         <td>2<sup>50</sup>=1 125 899 906 842 624</td>
         <td>10<sup>15</sup>=1 000 000 000 000 000</td>
        </tr>
        <tr>
         <td>exa</td>
         <td>E</td>
         <td>2<sup>60</sup>=1 152 921 504 606 846 976</td>
         <td>10<sup>18</sup>=1 000 000 000 000 000 000</td>
        </tr>
        <tr>
         <td>zetta</td>
         <td>Z</td>
         <td>2<sup>70</sup>=1 152 921 504 606 846 976</td>
         <td>10<sup>21</sup>=1 000 000 000 000 000 000 000</td>
        </tr>
        <tr>
         <td>yotta</td>
         <td>Y</td>
         <td>2<sup>80</sup>=1 208 925 819 614 629 174 706 176</td>
         <td>10<sup>24</sup>=1 000 000 000 000 000 000 000 000</td>
        </tr>

          
        </table>
     </ul>

     <h3>Investigación:</h3>
     <h4>MAC ADRESS</h4>
     <p>
      La dirección MAC es un identificador único que cada fabricante le asigna a la tarjeta de red de sus dispositivos conectados, desde un ordenador o móvil hasta 
      routers, impresoras u otros dispositivos como tu Chromecast. Sus siglas vienen del inglés, y significan Media Access Control. Como hay dispositivos con diferentes
      tarjetas de red, como una para WiFi y otra para Ethernet, algunos pueden tener diferentes direcciones MAC dependiendo de por dónde se conecten.
     </p>
     <p>
      Las direcciones MAC están formadas por 48 bits representados generalmente por dígitos hexadecimales. Como cada hexadecimal equivale a cuatro binarios (48:4=12),
      la dirección acaba siendo formada por 12 dígitos agrupados en seis parejas separadas generalmente por dos puntos, aunque también puede haber un guión o nada en 
      absoluto. De esta manera, un ejemplo de dirección MAC podría ser 00:1e:c2:9e:28:6b.
     </p>

     <h4>BIOS</h4>
     <p>
      El sistema básico de entrada-salida o BIOS es un estándar de facto que define la interfaz de firmware para computadoras IBM PC compatibles​. También es conocido 
      como BIOS del sistema, ROM BIOS y BIOS de PC. El nombre se originó en 1975, en el BIOS usado por el sistema operativo CP/M
     </p>

     <h4>ETHERNET</h4>
     <p>
      Es un estándar de redes de área local para computadoras, por sus siglas en español Acceso Múltiple con Escucha de Portadora y Detección de Colisiones. Su nombre 
      procede del concepto físico de éter.
     </p>

     <h4>dirección IP</h4>
     <p>
      es una etiqueta numérica que identifica de manera lógica y jerárquica a una interfaz —habitualmente un dispositivo — conectada a la red, que utilice el protocolo 
      de internet o que corresponda al nivel de red del modelo TCP/IP.
     </p>

     <h4>Raid</h4>
     <p>
      Un grupo/matriz redundante de discos independientes​ hace referencia a un sistema de almacenamiento de datos que utiliza múltiples unidades, entre las cuales se 
      distribuyen o replican los datos. 
     </p>

     <h4>VPN</h4>
     <p>
      Una red privada virtual es una tecnología de red de ordenadores que permite una extensión segura de la red de área local sobre una red pública o no controlada como Internet.
     </p>

     <h4>Sistemas de información:</h4>
     <p>
      Un sistema de información es el conjunto de agentes, códigos y procesos que interactúan coordinadamente entre sí con un fin común o propósito.
     </p>

     <h2 id="arqui">Arquitectura de Computadora</h2>
     <p>
      El concepto de arquitectura en el entorno informático proporciona una descripción de la construcción y distribución física de los componentes de la computadora.
     </p>

     <p>
      La arquitectura de una computadora explica la situación de sus componentes y permite determinar las posibilidades de que un sistema informático, con una 
      determinada configuración, pueda realizar las operaciones para las que se va a utilizar.
     </p>

     <ul>
        <li>Componentes básicos de una microcomputadora</li>
         <br>
         <ol type="a">
            <li>La tarjeta principal (Mother Board)</li>
            <li>La CPU</li>
            <li>La memoria</li>
            <li>Los buses</li>
            <li>La fuente de alimentación</li>
         </ol>
         <br>

        <li>Estructura de una computadora y sus periféricos</li>
         <div>
            <img src="imgPrimer/30 1.png" alt="">
         </div>

        <li>¿Qué es la tarjeta principal?</li>
        <br>
        <p>La “tarjeta principal“ (mainboard), o “tarjeta madre" (motherboard), es el elemento principal de toda computadora, en el que se encuentran o al que
          se conectan todos los demás dispositivos.</p>
          <p>
            Físicamente, se trata de una “tarjeta" de material sintético, sobre la cual existe un circuito impreso que conecta diversos elementos que se 
            encuentran anclados sobre ella.
          </p>
          <br>
        <li>Componentes de la tarjeta Principal</li>
        <br>
        <ul>
         <li>zócalo del microprocesador</li>
         <li>ranuras de memoria (SIMM, DIMM...)</li>
         <li>chipset de control</li>
         <li>BIOS</li>
         <li>slots de expansión (ISA, PCI, AGP...)</li>
         <li>Memoria Caché</li>
         <li>Conectores internos</li>
         <li>Conectores externos</li>
         <li>conector eléctrico</li>
         <li>Pila</li>
         <li>Elementos integrados variados</li>
        </ul>
        <div>
         <p><b>Una placa base moderna y típica ofrece un aspecto similar al siguiente</b></p>
         <img src="imgPrimer/32 1.png" alt="">
        </div>
        <br>
        <li>CPU</li>
        <br>
        <p>
         El CPU o Unidad de Procesamiento Central, es la parte central de toda la computadora ya que es la que cumple la tarea de procesamiento de todas las
         funciones así como también de almacenamiento de la información.
        </p>
        <p>
         Es un circuito electrónico que ha existido desde siempre en las computadoras sin importar su moedelo y es por eso que es considerado uno de los
         elementos básicos de cualquier computador
        </p>
        <div>
         <img src="imgPrimer/32 2.png" alt="">
        </div>

        <li>Ciclos de Reloj</li>
        <br>
        <p>
         Casi todas las computadoras son construidas usando un reloj (Oscilador de cristal), que es utilizado para sincronizar los eventos u operaciones: determinando
         cuándo ocurren (el paso) en el hardware.
        </p>
        <p>
         Estos intérvalos de tiempo, se denominan <b>ciclos de reloj</b>
        </p>
        <p>
         Los ciclos de reloj (Ej: 400 picosegundos (ps)) se suelen transofrmar o usar como <b>frecuencia de reloj</b> (2.5 gigahertz (GHz))
        </p>

        <div>
         <img src="imgPrimer/32 2.webp" alt="">
        </div>

        <li>Los buses</li>
        <br>
        <p>Los buses son los canales de datos que interconectan los componentes de la PC.</p>
        <p>Algunos están diseñados para transferencias pequeñas, y otros para transferencias mayores. </p>

        <div>
         <img src="imgPrimer/32 4.png" alt="">
        </div>

        <li>Buses en una computadora</li>
        <br>
        <p>Originalmente las primeras IBM PC, contaban con un bus único para interconectar todas las componentes del sistema, llamado BUS DEL SISTEMA.
         </p>
         <p>
            Con el tiempo éste empezó a ser incapaz de soportar los caudales de datos que requerían todos los componentes.
         </p>
         <div>
            <img src="imgPrimer/33 1.png" alt="">
         </div>
        <br>
         <p><b>El bus más importante de la PC se encarga del tráfico “pesado” entre la CPU y la memoria RAM</b></p>
         <p>
            Conocido como:
         </p>
         <ul>
            <li>Bus Frontal o Frontal Side Bus (FSB)</li>
            <li>Bus del sistema ( en PC ́s más antiguas)</li>
         </ul>
         <br>
         <div>
            <img src="imgPrimer/33 2.png" alt="">
         </div>
         <br>
         <h4>Tipos Genéricos de Buses:</h4>
         <ul>
            <li>Bus del sistema, que es el encargado de unir la CPU con la memoria RAM y otros elementos de la tarjeta madre.</li>
            <li>Bus de Entrada/Salida, que une la tarjeta madre con otros adaptadores y tarjetas ( de video, gráficas, discos duros etc.)</li>
         </ul>
         <br>
         <div>
            <img src="imgPrimer/33 3.png" alt="">
         </div>
         <br>

        <li>BUS PCI</li>
        <br>
        <ul>
         <li>Bus de expansión diseñado para los ix86 y Pentium.</li>
         <li>Actualmente se encuentra en todos los computadores personales.</li>
         <li>Soporta hasta 10 periféricos de alta velocidad.</li>
         <li>Permite conexión con otros buses más</li>
        </ul>
        <ol type="a">
         <li>Bus de datos de 32 bits en la versión 2.0 y de 64 bits en la versión 2.1.</li>
         <li>Bus de direcciones de 32 bits.</li>
         <li>Funciona a 33 MHz (versión 2.0) o a 66 MHz (versión2.1).</li>
         <li>La velocidad de transferencia máxima es</li>
        </ol>
        <br>
        <div>
         <img src="imgPrimer/34 1.png" alt="">
         <img src="imgPrimer/34 2.png" alt="">
        </div>
        <br>
        <h4>¿Qué diferencias tienen el bus PCI 32 bits respecto al PCI de 64 bits?</h4>
        <p>
         La diferencia fundamental entre las diferentes versiones de buses PCI es principalmente la capacidad de datos que pueden procesar en una unidad de tiempo, es 
         decir, el ancho de banda que son capaces de soportar.
        </p>
        <p>
         Este ancho de banda máximo o teórico se calcula multiplicando el número de bits utilizado por el bus para transferir datos en paralelo por la frecuencia de 
         funcionamiento.
        </p>
        <p>
         El bus PCI estándar utiliza datos de 32 bits y funciona a una frecuencia de 33 MHz. El máximo ancho de banda que admiten estos buses es de: 32 bits = 4 bytes 
         por ciclo de reloj; 4 * 33.333 = 133.332 KBps = 133 MBps.
        </p>
        <p>
         Algunas placas utilizan buses PCI de 32 bits y 66 MHz, aumentando así la capacidad máxima de transferencia de los PCI originales, hasta 266 MBps.
        </p>
        <p>
         También existen bus PCI de 64 bits y 33 MHz, y de 64 bits y 66 Mhz.
        </p>
        <br>
        <table>
         <tr>
            <th>Nombre</th>
            <th>Año</th>
            <th>Anchura de datos</th>
            <th>Velocidad de trasferencia</th>
         </tr>
         <tr>
            <td>ISA (Bus-PC, PC-XT)</td>
            <td>1980-82</td>
            <td>8 bits</td>
            <td>4-6MB/s</td>
         </tr>
         <tr>
            <td>ISA-AT</td>
            <td>1984</td>
            <td>16 bits</td>
            <td>8-16,7MB/s</td>

         </tr>
         <tr>
            <td>MCA</td>
            <td>1987</td>
            <td>32 bits</td>
            <td>40 MB/s</td>
         </tr>
         <tr>
            <td>EISA</td>
            <td>1988</td>
            <td>32 bits</td>
            <td>32 MB/s</td>
         </tr>
         <tr>
            <td>VL-Bus</td>
            <td>1993</td>
            <td>32-64 bits</td>
            <td>132 MB/s, 250 MB/s</td>
         </tr>
         <tr>
            <td>PCI</td>
            <td>1991</td>
            <td>32, 64 bits</td>
            <td>133 MB/s, 264 MB/s</td>
         </tr>
         <tr>
            <td>PCI 2.0</td>
            <td>1993</td>
            <td>32, 64 bits</td>
            <td>264 MB/s, 528 MB/s</td>
         </tr>
         <tr>
            <td>PCI-X2.0</td>
            <td>2002</td>
            <td>32, 64 bits</td>
            <td>2,1 GB/s, 4,2 GB/s</td>
         </tr>
        </table>
        
        <br>
        <li>Generaciones de Microprocesadores</li>
        <br>
        <table>
         <tr>
            <th>Generacion</th>
            <th>CPU</th>
            <th>AÑO</th>
            <th>Transistores</th>
         </tr>
         <tr>
            <td>1era</td>
            <td>8086,8088</td>
            <td>1978-1981</td>
            <td>29,000</td>
         </tr>
         <tr>
            <td>2da</td>
            <td>80286</td>
            <td>1984</td>
            <td>134,000</td>
         </tr>
         <tr>
            <td>3ra</td>
            <td>80386Dx</td>
            <td>1987-88</td>
            <td>275,000</td>

         </tr>
         <tr>
            <td>4ta</td>
            <td>80486SX, 486DX</td>
            <td>1990-92</td>
            <td>1,200,000</td>

         </tr>
         <tr>
            <td>5ta</td>
            <td>Pentium / AMD K5</td>
            <td>1993-95</td>
            <td>3,100,000</td>
         </tr>
         <tr>
            <td>6ta</td>
            <td>Pentium Pro /AMD K6</td>
            <td>1995-98</td>
            <td>5,500,000</td>
         </tr>
         <tr>
            <td>7ma</td>
            <td>AMD K7 / Pentium 4</td>
            <td>1999-2000</td>
            <td>22,000,000</td>
         </tr>
         <tr>
            <td>8va</td>
            <td>Atholn 64 / Prescott</td>
            <td>2003</td>
            <td>100,000,000</td>
         </tr>
        </table>
        <div>
         <img src="imgPrimer/34 5.png" alt="">
         
         <img src="imgPrimer/35 2.png" alt="">
         <img src="imgPrimer/35 3.png" alt="">
         <img src="imgPrimer/35 4.png" alt="">
        </div>

     </ul>

     <h2 id="intro">Introducción a los Sistemas Operativos</h2>
     <div>
      <img src="imgPrimer/36 1.png" alt="">
      <img src="imgPrimer/36 2.png" alt="">
      <img src="imgPrimer/36 3.png" alt="">
     </div>
     <br>
     <ul>
        <li>Sistema Operativo</li>
         <br>
         <p>
            Sistema tipo software que controla la computadora y administra los servicios y sus funciones como así también la ejecución de otros programas compatibles con éste.
         </p>
         <p>
            Ejemplos de familias de sistemas operativos: Windows, Unix, Linux, DOS, Mac OS, etc.
         </p>
         <p>
            Un sistema operativo permite interactuar con el hardware de computadoras, teléfonos celulares, PDAs, etc. y ejecutar programas compatibles en éstos.
         </p>
         <p>
            Permite controlar las asignaciones de memoria, ordenar las solicitudes al sistema, controlar los dispositivos de entrada y salida, facilitar la conexión a redes y 
            el manejo de archivos.
         </p>
         <br>
        <li>Servicios del Sistema Operativo</li>
   
         <ul>
            <li><b> Ejecución de programas</b>capacidad del sistema de cargar un programa en memoria y ejecutarlo.</li>
            <li><b>Operaciones de E/S</b> dado que los programas no pueden ejecutar operaciones de E/S directamente, el sistema operativo debe proveer medios para realizarlas.</li>
            <li><b>Manipulaciones del sistema de archivos </b>capacidad de los programas de leer, escribir, crear y borrar archivos.</li>
            <li><b>Comunicaciones </b>intercambio de información entre procesos ejecutando en la misma computadora o en otra conectada a través de una red. Implementada mediante memoria 
               compartida o por paso de mensajes.</li>
            <li><b>detección de errores </b>asegurar un cómputo correcto mediante la detección de errores  en el CPU, memoria, dispositivos de E/S o en los programas de usuario.</li>
         </ul>
         <br>
        <li>Estructura de un Sistema Operativo</li>
        <br>
        <div>
         <img src="imgPrimer/38 1.png" alt="">
        </div>
        <br>
        <p>
         Programa que actúa como interfaz entre el usuario de un ordenador y el hardware del mismo, ofreciendo el entorno necesario para que el usuario pueda ejecutar
          programas.
        </p>
        <ul>
         <li><h4>Visión de una Máquina virtual</h4></li>
        </ul>
        <p>
         Presenta al usuario una máquina abstracta más fácil de programar que el hardware subyacente, ocultando su complejidad, y dando un tratamiento homogéneo a 
         diferentes objetos de bajo nivel (archivos, proceso, dispositivos)
        </p>
        <ul>
         <li><h4>Visión de Gestor de Recursos</h4></li>
        </ul>
        <p>
         Controla y protege los recursos (procesador, dispositivos de E/S, memoria, etc.) entre los procesos y usuarios que compiten por ellos.
        </p>
        <br>
        <li>Evolución de los SSOO (1/6)</li>
        <h4>Monitor simpre residente</h4>
        <p>
         Un solo fragmento de código que se enlazabacon los programas, cargándose todo en memoria y ejecutándose junto con el programa (“biblioteca en tiempo de ejecución”)
        </p>
        <h4>Sistemas por lotes (batch)</h4>
        <p>
         <ul>
            <li>Se podrían considerar como los primeros SSOOs reales</li>
            <li>El SSOO estaba almacenado en memoria</li>
            <li>Cargaba un único trabajo en memoria (desde el lector de tarjetas)</li>
         </ul>
        </p>
         <br>

        <li>Evolución de los SSOO (2/6)</li>
        <br>
        <ul>
         <li>Ejecutaba el trabajo (generaba su salida) </li>
         <li>Cargaba el siguiente trabajo</li>
         <li>Las tarjetas de control indicaban qué hacer al SSOO</li>
         <li><h4>Problemas</h4></li>
         <ul>
            <li>Largas esperas entre lotes de trabajo</li>
            <li>La dificultad de manejar la concurrencia entre E/S y ejecución en CPU ayudó a estimular el desarrollo de los SSOO multiprogramados</li>
            <li>Carecen de interactividad entre el usuario y los trabajos que se ejecutan.</li>
         </ul>
        </ul>
        <br>
        <li>Evolución de los SSOO (3/6)</li>
        <br>
        <h4>Multiprogramación</h4>
        <ul>
         <li><b>Objetivo: </b>Aprovechar los tiempos de espera de un trabajo en la CPU para ejecutar instrucciones de otro trabajo</li>
        </ul>
        <h4>Método:</h4>
        <ul>
         <li>Mantener los trabajos simultáneamente en memoria</li>
         <li>Elegir el trabajo a conmutar</li>
         <li>Necesidad de usar interrupciones o DMA</li>
         <li>Se optimiza la productividad (throughput)
            del sistema
            </li>
        </ul>
        <br>


        <li>Evolución de los SSOO (4/6)</li>
        <h4>Elementos necesarios</h4>
        <ul>
         <li>Las rutinas de E/S deben estar suministradas por el SSOO</li>
         <li>Debe existir una gestión de memoria para poder asignar y controlar la memoria repartida entre varios trabajos</li>
         <li>- Debe existir una planificación de la CPU. El SSOO debe elegir uno de entre los diferentes trabajos listos para ejecutarse que hay en memoria</li>
         <li>La asignación de los dispositivos es realizada por el SSOO</li>
        </ul>

        <br>
        <li>Evolución de los SSOO (5/6)</li>
        <br>
        <h4>Tiempo Compartido</h4>
        <ul>
            <li><b>Objetivo:</b> Permitir la interacción entre el usuario y el trabajo que se está ejecutando.</li>
        </ul>
        <h4>Método</h4>
        <ul>
         <li>Utilizar las técnicas de multiprogramación y planificación de la CPU para proporcionar a cada usuario una pequeña proporción del tiempo de CPU.</li>
        </ul>
        <h4>Características</h4>
        <ul>
         <li>Cada usuario tiene la impresión de disponer de la máquina completa.</li>
         <li>Se intenta optimizar el tiempo de respuesta.</li>
         <li>Basados en la asignación de fracciones de tiempo (se divide el tiempo de CPU de forma equitativa entre los procesos).</li>
        </ul>
        <br>

        <li>Evolución de los SSOO (6/6)</li>
        <br>
        <h4>Sistemas de tiempo real</h4>
        <ul>
         <li>El factor tiempo se convierte en una variable fundamental.</li>
         <li>Muy utilizados en sistemas empotrados.</li>
         <li>El sistema operativo debe responder siempre dentro de los márgenes requeridos por el sistema controlado, si nos salimos de esos márgenes, tendremos que 
            buscar otras soluciones.</li>
         <li>Existen actualmente lenguajes de programación (Ada) que nos dan grandes posibilidades para controlar procesos en tiempo real.</li>
        </ul>
        <br>

        <li>Entorno Hardware</li>
        <br>
        <ul>
         <li>Sistema computador</li>
         <li>Interrupciones y excepciones</li>
         <li>Modo dual de operación</li>
         <li>Protección de memoria</li>
         <li>Protección de la CPU</li>
        </ul>
     </ul>
     <br>
     <h2 id="estructuracion">Estructuración de los Sistemas Operativos</h2>
     <ul>
        <li>Estructura monolitica</li>
         <br>
      <p>
         Es la estructura de los primeros sistemas operativos constituidos fundamentalmente por un solo programa compuesto de un conjunto de procedimientos entrelazados 
         de tal forma que cada uno puede llamar a cualquier otro. Las características fundamentales de este tipo de estructura son:
      </p>
      <ul>
         <li>Construcción del programa final a base de módulos compilados separadamente que se unen a través del ligador.</li>
         <li>Buena definición de parámetros de enlace entre las distintas rutinas existentes, que puede provocar mucho acoplamiento.</li>
         <li>Carecen de protecciones y privilegios al entrar a rutinas que manejan diferentes aspectos de los recursos de la computadora, como memoria, disco, etc.</li>
      </ul>
      <p>
         Generalmente están hechos a medida, por lo que son eficientes y rápidos en su ejecución y gestión, pero por lo mismo carecen de flexibilidad para soportar 
         diferentes ambientes de trabajo o tipos de aplicaciones.
      </p>

      <br>
      <div>
         <img src="imgPrimer/40 1.png" alt="">
      </div>
      <br>
        <li>Estructura en capas</li>
        <br>
        <ul>
         <li>A medida que fueron creciendo las necesidades de los usuarios y se perfeccionaron los sistemas, se hizo necesaria una mayor organización del software, del 
            sistema operativo, donde una parte del sistema contenía subpartes y esto organizado en forma de niveles.</li>
            <li>Se dividió el sistema operativo en pequeñas partes, de tal forma que cada una de ellas estuviera perfectamente definida y con un claro interface con el 
               resto de elementos.</li>
         <li>Se constituyó una estructura jerárquica o de niveles en los sistemas operativos, el primero de los cuales fue denominado THE (Technische Hogeschool, 
            Eindhoven), de Dijkstra, que se utilizó con fines didácticos. Se puede pensar también en estos sistemas como si fueran `multicapa'. Multics y Unix caen en
             esa categoría</li>
        </ul>
        <br>
        <div>
         <img src="imgPrimer/40 2.png" alt="">
         <p>
            En la estructura anterior se basan prácticamente la mayoría de los sistemas operativos actuales. Otra forma de ver este tipo de sistema es la denominada de 
            anillos concéntricos o "rings".
         </p>
        </div>
        <br>
        <li>Máquina Virtual</li>
        <br>
        <ul>
         <li>Se trata de un tipo de sistemas operativos que presentan una interface a cada proceso, mostrando una máquina que parece idéntica a la máquina real 
            subyacente. Estos sistemas operativos separan dos conceptos que suelen estar unidos en el resto de sistemas: la multiprogramación y la máquina extendida. 
            El objetivo de los sistemas operativos de máquina virtual es el de integrar distintos sistemas operativos dando la sensación de ser varias máquinas 
            diferentes.</li>
         <li>El núcleo de estos sistemas operativos se denomina monitor virtual y tiene como misión llevar a cabo la multiprogramación, presentando a los niveles 
            superiores tantas máquinas virtuales como se soliciten. Estas máquinas virtuales no son máquinas extendidas, sino una réplica de la máquina real, de manera 
            que en cada una de ellas se pueda ejecutar un sistema operativo diferente, que será el que ofrezca la máquina extendida al usuario.</li>
        </ul>
        <br>
        <div>
         <img src="imgPrimer/40 3.png" alt="">
        </div>
        <br>
        <li>Cliente-servidor(Microkernel).</li>
        <br>
        <ul>
         <li>El tipo más reciente de sistemas operativos es el denominado cliente-servidor, que puede ser ejecutado en la mayoría de las computadoras, ya sean grandes o 
            pequeñas.</li>
         <li>
            Este sistema sirve para toda clase de aplicaciones por tanto, es de propósito general y cumple con las mismas actividades que los sistemas operativos convencionales.
         </li>
         <li>
            El núcleo tiene como misión establecer la comunicación y los servidores. Los procesos pueden ser tanto servidores como clientes. Por ejemplo, un programa de 
            aplicación normal es un cliente que llama al servidor correspondiente para acceder a un archivo o realizar una operación de entrada/salida sobre un 
            dispositivo concreto. A su vez, un proceso cliente puede actuar como servidor para otro".
         </li>
         <li>
            Este paradigma ofrece gran flexibilidad en cuanto a los servicios posibles en el sistema final, ya que el núcleo provee solamente funciones muy básicas de 
            memoria, entrada/salida, archivos y procesos, dejando a los servidores proveer la mayoría que el usuario final o programador puede usar. Estos servidores 
            deben tener mecanismos de seguridad y protección que, a su vez, serán filtrados por el núcleo que controla el hardware.
         </li>

        </ul>
        <br>
        <li>Sistema Computador (3/3)</li>
        <br>
        <ul>
         <li>Los controladores de dispositivos tienen un búfer local, colas de peticiones y registros de control/estado.</li>
         <li>La CPU transfiere los datos de/a memoria principal a/de los búferes locales.</li>
         <li>Las E/S se realizan desde el dispositivo al búfer local del controlador.</li>
         <li>Los controladores de dispositivo informan a la CPU que han finalizado mediante una interrupción.</li>
        </ul>
        <br>
        <li>Interrupciones y excepciones (4/5)</li>
        <br>
        <h4>Gestor de excepciones:</h4>
        <ul>
         <li>Al detectarse la excepción, se transfiere el control al manejador de excepciones (igual que en las interrupciones).</li>
         <li>Las excepciones se tratan en espacio de usuario.</li>
         <li>El SSOO simplemente las notifica.</li>
        </ul>
        <br>
        <li>Entidad de ejecución (proceso)</li>
        <br>
        <ul>
         <li>Proceso  Programa en ejecución</li>
         <li>Proceso  Programa cargado en memoria y con recursos asignados</li>
        </ul>
        <h4>Responsabilidades del SSOO</h4>
        <ul>
         <li>crear/destruir procesos</li>
         <li>suspender/reanudar procesos</li>
         <li>suministrar mecanismos para sincronizar y comunicar procesos</li>
        </ul>
        <br>
        <li>Componentes (1/5)</li>
        <br>
        <ul>
         <li>Gestor de memoria principal</li>
         <ul>
            <li>Asignar/Desasignar memoria a los programas</li>
            <li>Conocer en todo momento la memoria utilizada y quien la usa</li>
            <li>Decidir el tamaño de memoria que se asigna a cada proceso y cuando debe ser retirado de la misma</li>
         </ul>
        </ul>
        <br>
        <li>Componentes (2/5)</li>
        <br>
        <ul>
         <li>Gestor de archivos</li>
         <ul>
            <li>Archivo  Colección de datos (información) referenciada bajo un nombre.</li>
            <li>Operaciones sobre archivos:</li>
            <ul>
               <li>Crear/borrar archivos o (directorios)</li>
               <li>Llamadas al sistema para su manipulación: leer, escribir,
                  renombrar, etc.
                  </li>
                  <li>Servicios de backup, cuotas, etc</li>
            </ul>
         </ul>
        </ul>
        <br>
        <li>Componentes (3/5).</li>
        <br>
        <ul>
         <li>Gestor de E/S</li>
         <ul>
            <li>Los SSOOs modernos proporcionan una I/F estándar entre los programas
               y los dispositivos, es decir, utilizan las mismas funciones independientemente del dispositivo.
               </li>
            <li>El módulo del SSOO responsable de gestionar el tipo de dispositivo y encapsular el conocimiento específico del dispositivo es el manejador de dispositivo.</li>
         </ul>
        </ul>
        <br>
        <li>Componentes (4/5)</li>
        <br>
        <ul>
         <li>Sistema de Protección</li>
         <ul>
            <li><b>Objetivo:</b> Controlar los accesos de programas, procesos o usuarios, al sistema o a los recursos de usuario.</li>
            <li><b>Método</b></li>
            <ul>
               <li>Distinguir entre uso autorizado o no</li>
               <li>Especificar el control que se debe imponer</li>
               <li>Suministrar los medios para su aplicación</li>
            </ul>
            <li>
               El sistema de protección no está localizado en un único módulo, sino que que es un mecanismo general a todo el SSOO.
            </li>
         </ul>
        </ul>
        <br>
        <li>Componentes (5/5)</li>
        <br>
        <ul>
         <li>Intérprete de órdenes</li>
         <ul>
            <li>Proceso que maneja la interpretación de órdenes del usuario desde un terminal, para utilizar los servicios que proporciona el SSOO.</li>
            <li>Este proceso hace de interfaz con el usuario u operador del sistema. (csh, bash, ksh, etc.)</li>
         </ul>
        </ul>
        <br>
        <h4>Propiedades</h4>
        <ul>
         <li>Eficacia</li>
         <ul>
            <li>Consumo: >40% de los ciclos de CPU</li>
         </ul>
         <li>Fiabilidad</li>
         <ul>
            <li>Robustez: El SSOO debe responder de forma predecible a casos de error, incluidos fallos HW</li>
            <li>Protección: El SSOO debe protegerse a sí mismo y a los usuarios de acciones accidentales o malintencionadas.</li>
         </ul>
         <li>Extensibilidad</li>
         <ul>
            <li>Variar o crecer la funcionalidad del SSOO de forma sencilla.</li>
         </ul>
        </ul>
        <br>
        <li>Tipos de estructuras o arquitecturas(1/6)</li>
        <br>
        <ul>
         <li>Monolítica</li>
         <ul>
            <li>Toda la funcionalidad del SSOO se incluye en el núcleo</li>
            <li>Todos los componentes del SSOO se ejecutan en modo supervisor</li>
            <li>Empleado en sistemas pequeños</li>
            <li>Difícil de modificar en tiempo de ejecución</li>
            <li>Difícil de mantener</li>

         </ul>
        </ul>
        <br>
        <li>Tipos de estructuras o arquitecturas(2/6)</li>
        <br>
        <ul>
         <li>Partes diferenciadas</li>
         <ul>
            <li>Núcleo Dependiente</li>
            <ul>
               <li>Manejar las interrupciones del HW</li>
               <li>Manejo de bajo nivel de memoria y discos</li>
               <li>Trabajar con los manejadores de dispositivos de bajo nivel</li>
            </ul>
            <li>
               Núcleo Independiente
            </li>
            <ul>
               <li>Ofrece las llamadas al sistema (“system calls”)</li>
               <li>Manejar los sistemas de archivos</li>
               <li>Gestionar la planificación de procesos</li>
            </ul>
         </ul>
        </ul>
        <br>
        <li>Tipos de estructuras o arquitecturas(3/6)</li>
        <br>
        <div>
         <img src="imgPrimer/42 1.png" alt="">
        </div>
        <br>
        <li>Tipos de estructuras o arquitecturas(4/6)</li>
        <br>
        <ul>
         <li>μKernel</li>
         <ul>
            <li>Manejo de procesos e hilos</li>
            <li>Manejo bajo de memoria</li>
            <li>Soporte a las comunicaciones</li>
            <li>Manejo de interrupciones y operaciones de bajo nivel de E/S</li>
            <li>Se usan procesos “servidores” que se encargan de ofrecer el resto de servicios (por ejemplo el de sistema de archivos)</li>
            <li>Menor rendimiento que la arquitectura monolítica debido a la sobrecarga de comunicaciones</li>

         </ul>
        </ul>
        <br>
        <li>Tipos de estructuras o arquitecturas(5/6) </li>
        <br>
        <ul>
         <li>Empleado en sistemas grandes</li>
         <li>Fácil de modificar en tiempo de ejecución</li>
         <li>Más adpatable que la arquitectura monolítica</li>
         <li>Sólo el micronúcleo se ejecuta en modo supervisor</li>
        </ul>
        <br>
        <li>Tipos de estructuras o arquitecturas(6/6)</li>
        <br>
        <div>
         <img src="imgPrimer/43 1.png" alt="">
        </div>
     </ul>
     <br>
     <h2>Recursos Administrados por el S.O</h2>
     <h4>Ejemplo de un Proceso</h4>
     <div>
      <img src="imgPrimer/44 1.png" alt="">
     </div>
     <br>
     <ul>
        <h3 id="control">Control de Procesos</h3>
        <li>¿Qué es un proceso?</li>
        <p>Un proceso puede informalmente entenderse como un programa en ejecución. Formalmente un proceso es "Una unidad de actividad que se caracteriza por la 
         ejecución de una secuencia de instrucciones, un estado actual, y un conjunto de recursos del sistema asociados.</p>
        <li>Modelo de Procesos</li>
        <p>Posee las siguientes Característica:</p>
        <ul>
         <li>Todo el software ejecutable, inclusive el Sistema Operativo, se organiza en varios procesos secuenciales o procesos.</li>
         <li>Un proceso incluye al programa en ejecución y a los valores activos del contador, registros y variables del mismo.</li>
         <li>Conceptualmente cada proceso tiene su propia CPU virtual.</li>
         <li>Un proceso es una actividad de un cierto tipo, que tiene un programa, entrada, salida y estado.</li>
        </ul>
        <br>
        <h4>Modelo de procesos:</h4>
        <p>Un solo procesador puede ser compartido entre varios procesos con cierto “algoritmo de planificación”, el cual determina cuándo detener el trabajo en un 
         proceso y dar servicio a otro distinto.</p>
         <br>
         <div>
            <img src="imgPrimer/44 2.png" alt="">
         </div>
         <br>
         <p>En cuanto a las jerarquías de procesos es necesario señalar que los Sistemas Operativos deben disponer de una forma de crear y destruir procesos cuando se 
            requiera durante la operación, teniendo además presente que los procesos pueden generar procesos hijos mediante llamadas al Sistema Operativo, pudiendo 
            darse ejecución en paralelo.</p>

        <li>¿Qué es un sistema Operativo Multihilo</li>
        <ul>
         <li>Es aquel Sistema Operativo que posee varios hilos de ejecución.</li>
         <li>Un hilo de Ejecución o subproceso es una característica que permite a una aplicación realizar varias tareas a la vez (concurrentemente). </li>
         <li>Los distintos hilos de ejecución comparten una serie de recursos tales como el espacio de memoria, los archivos abiertos, situación de autenticación, etc.</li>
         <li>Los procesos son creados y destruidos por el sistema operativo, así como también este se debe hacer cargo de la comunicación entre procesos, pero lo hace 
            a petición de otros procesos.</li>
         <li>El mecanismo por el cual un proceso crea otro proceso se denomina bifurcación (fork). Los nuevos procesos son independientes y no comparten memoria (es 
            decir, información) con el proceso que los ha creado.</li>
         <li>En los sistemas operativos multihilo es posible crear tanto hilos como procesos. La diferencia es en que un proceso solamente puede crear hilos para sí mismo.
            No hay un acuerdo universal sobre una definición de proceso,
            </li>

        </ul>

        <br>
        <p><b>No hay un acuerdo universal sobre una definición de proceso, pero sí algunas definiciones aceptadas:
         </b></p>
         <ul>
            <li>Un programa que se está ejecutando.</li>
            <li>Una actividad asincrónica.</li>
            <li>El emplazamiento del control de un procedimiento que está
               siendo ejecutado.
               </li>.
            <li>Aquello que se manifiesta por la existencia en el Sistema
               Operativo de un bloque de control de proceso.
               </li>
            <li>Aquella entidad a la cual son asignados los procesadores.</li>
            <li>La unidad despachable</li>
         </ul>
         <br>
        <li>Estados de un proceso</li>
        <br>
        <p>El principal trabajo del procesador es ejecutar las instrucciones de máquina que se encuentran en memoria principal. Estas instrucciones se encuentran en 
         forma de programas. Para que un programa pueda ser ejecutado, el sistema operativo crea un nuevo proceso, y el procesador ejecuta una tras otra las 
         instrucciones del mismo.</p>
         <br>
         <ul>
            <li>Cada proceso es una entidad independiente pero frecuentemente debe interactuar con otros procesos.</li>
            <p><b>Los procesos pueden bloquearse en su ejecución porque:</b></p>
            <li>Desde el punto de vista lógico no puede continuar porque espera datos que aún no están disponibles.</li>
            <li>El Sistema Operativo asignó la CPU a otro proceso.</li>
            <p><b>Los estados que puede tener un proceso son:</b></p>
            <li><b>En ejecución:</b> utiliza la CPU en el instante dado.</li>
            <li><b>Listo:</b> ejecutable, se detiene en forma temporal para que se ejecute otro proceso.</li>
            <li><b>Bloqueado:</b> no se puede ejecutar debido a la ocurrencia de algún evento externo.</li>
         </ul>
        <h3 id="modelo">Modelo de Estados</h3>
        <li>Modelo de dos estados</li>
        <div>
         <img src="imgPrimer/46 1.png" alt="">
        </div>
        <br>
        <ul>
         <li>En este modelo, un proceso puede estar ejecutándose o no. Cuando se crea un nuevo proceso, se pone en estado de No ejecución.</li>
         <li>En algún momento el proceso que se está ejecutando pasará al estado No ejecución y otro proceso se elegirá de la lista de procesos listos para ejecutar 
            para ponerlo en estado Ejecución.</li>
         <li>De esta explicación se desprende que es necesario que el sistema operativo pueda seguirles la pista a los procesos, conociendo su estado y el lugar que 
            ocupa en memoria. Además, los procesos que no se están ejecutando deben guardarse en algún tipo de cola mientras esperan su turno para ejecutar.</li>
        </ul>
        <br>
        <li>Modelo de cinco estados</li>
        <br>
        <div>
         <img src="imgPrimer/47 1.png" alt="">
        </div>
        <br>
        <ul>
         <li>El modelo anterior de dos estados funcionaría bien con una cola FIFO y planificación por turno rotatorio para los procesos que no están en ejecución, si 
            los procesos estuvieran siempre listos para ejecutar.</li>
         <li>En la realidad, los procesos utilizan datos para operar con ellos, y puede suceder que no se encuentren listos, o que se deba esperar algún suceso antes 
            de continuar, como una operación de Entrada/Salida.</li>
         <li>Es por esto que se necesita un estado donde los procesos permanezcan bloqueados esperando hasta que puedan proseguir.</li>
         <li>Se divide entonces al estado No ejecución en dos estados: Listo y Bloqueado. Se agregan además un estado Nuevo y otro Terminado.</li>
        </ul>
        <br>
        <p><b>Los cinco estados del diagrama son los siguientes:</b></p>
        <br>
        <ul>
         <li><b>Ejecución: </b> El proceso está actualmente en ejecución.</li>
         <li><b>Listo: </b>El proceso está listo para ser ejecutado, sólo está esperando que el planificador así lo disponga. </li>
         <li><b>Bloqueado: </b>El proceso no puede ejecutar hasta que no se produzca cierto suceso, como una operación de Entrada/Salida.</li>
         <li><b>Nuevo: </b>El proceso recién fue creado y todavía no fue admitido por el sistema operativo. En general los procesos que se encuentran en este estado 
            todavía no fueron cargados en la memoria principal. </li>
         <li><b>Terminado: </b>: El proceso fue expulsado del grupo de procesos ejecutables, ya sea porque terminó o por algún fallo, como un error de protección, 
            aritmético, etc.</li>
        </ul>
        <br>
        <ul>
         <li>Los nuevos estados Nuevo y Terminado son útiles para la gestión de
            procesos. En este modelo los estados Bloqueado y Listo tienen
            ambos una cola de espera.
            </li>
         <li>
            Cuando un nuevo proceso es admitido por el sistema operativo, se
            sitúa en la cola de listos. A falta de un esquema de prioridades ésta
            puede ser una cola FIFO. Los procesos suspendidos son mantenidos
            en una cola de bloqueados. Cuando se da un suceso se pasan a la
            cola de listos los procesos que esperaban por ese suceso.

         </li>
         <li>
            Si existe un esquema con diferentes niveles de prioridad de procesos
            es conveniente mantener varias colas de procesos listos, una para
            cada nivel de prioridad, lo que ayuda a determinar cuál es el proceso
            que más conviene ejecutar a continuación.

         </li>
        </ul>
        <br>
        <br>
        <h3 id="estados">Estados De Un Proceso</h3>
        <p>Durante su existencia un proceso pasa por una serie de estados discretos, siendo varias las circunstancias que pueden hacer que el mismo cambie de estado.</p>
        <p>Debido a ello se puede establecer una <b>“Lista de Listos”</b> para los procesos “listos” y una <b>“Lista de Bloqueados”</b> para los “bloqueados”.</p>
        <br>
        <li>Lista de Listos</li>
        <br>
        <ul>
         <li>La “Lista de Listos” se mantiene en orden prioritario y la “Lista de Bloqueados” está desordenada, ya que los procesos se desbloquean en el orden en que 
            tienen lugar los eventos que están esperando.</li>
         <li>Al admitirse un trabajo en el sistema se crea un proceso equivalente y es insertado en la última parte de la “Lista de Listos”.</li>
         <li>La asignación de la CPU al primer proceso de la “Lista de Listos” se denomina “Despacho”, que es ejecutado por una entidad del Sistema Operativo llamada “Despachador”.</li>
        </ul>
        <br>
        <li>Bloqueados</li>
        <br>
        <ul>
         <li>El “Bloqueo” es la única transición de estado iniciada por el propio proceso del usuario, puesto que las otras transiciones son iniciadas por entidades ajenas al proceso.</li>
        </ul>
        <br>
        <li>Programa vs Proceso</li>
        <br>
        <h4><u><b>Programa:</b></u></h4>
        <p>Conjunto de instrucciones, código. Elemento Pasivo.</p>
        <br>
        <h4><u><b>Proceso:</b></u></h4>
        <p>Programa en ejecución. (Entre dinámico).</p>
        <p>Un programa puede levantar varios procesos.</p>
        <p>Tiene asociado un espacio de direcciones.</p>
        <br>
        <div>
         <img src="imgPrimer/48 1.png" alt="">
        </div>
        <br>
        <li>Espacio de Direcciones</li>
        <br>
        <p>El espacio de direcciones es el espacio en memoria asignado al proceso. Aquí se encuentra el código del proceso y los datos que este utiliza.</p>
        <p>Desde el punto de vista del proceso, el Address Space es la única memoria existente en el sistema, no pudiendo acceder a direcciones foráneas.</p>
        <p>En el caso de sistemas sin paginación, el espacio de direcciones no puede ser particionado en páginas, y ser cargado por partes o llevado parcialmente 
         a swap; resultando en que el bloque de memoria esta realmente presente ya sea en RAM o disco.</p>
         <br>
         <div id="espacio">
            <img src="imgPrimer/49 1.png" alt="">
         </div>
         <div id="espacio1">
            <p>Cuando se tiene paginación, entonces el espacio de direcciones es dividido en páginas, y resultando en que no todo este en RAM, sino solo una porción.
               A este concepto de un espacio que realmente no esta por completo ni en memoria, ni en disco; se le denomina <b>Espacio de Direcciones Virtual.</b> </p>
         </div>
         <br>
        <li>Process Control Block (BCP O PCB)</li>
        <p>
         El sistema operativo, para correr un proceso, necesita saber cierta información importante de él, y esta, se encuentra almacenada en un registro, que es el 
         "Bloque de control de proceso BCP".
        </p>
        <p>
         Cuando un proceso termina, su información que estaba almacenada en el Bloque se elimina, y este puede ser utilizado por otros procesos.
        </p>
        <br>
        <li>Tabla de procesos</li>
        <br>
        <p>La tabla de procesos, es una estructura en memoria que contiene la ubicación de los PCB de todos los procesos del sistema. A través de esta, el kernel 
         puede conocer el estado de cada proceso, saber en parte de la memoria se encuentra, etc.</p>
         <br>
         <div>
            <img src="imgPrimer/52 1.png" alt="">
         </div>
         <br>
        <li>Ubicación de los procesos</li>
        <div>
         <img src="imgPrimer/53 1.png" alt="">
        </div>

     </ul>

     <h2 id="linux">Todo sobre LINUX</h2>
     <ul>
        <li>Algunos comandos Básicos</li>
        <br>
        <p>Algunos de ellos como man, ls, chmod y umask ya han sido referenciados, otros se mencionarán más adelante en dependencia de los temas que se traten. 
         Muchos de estos comandos están presentes también en los sistemas Unix aunque a veces varían sus opciones y argumentos en dependencia de las versiones.
          Por esto no puede encontrarse una documentación que diga la última palabra respecto a uno u otro comando, la práctica es la mejor forma de comprobar
           como funciona cada uno. Para su mejor comprensión los clasificamos en diferentes categorías.</p>
           <br>
        <li>Categorías</li>
        <br>
        <ul>
         <li>Comandos para manipular ficheros y directorios</li>
         <li>Comandos para paginar, visualizar y editar ficheros</li>
         <li>Comandos para hacer búsquedas de ficheros y patrones</li>
         <li>Comandos para filtrar ficheros</li>
         <li>Comandos para compactar y agrupar ficheros</li>
         <li>Comandos para la comunicación entre usuarios</li>
         <li>Comandos para desconectarse del sistema</li>
         <li>Comandos para administrar usuarios y grupos</li>
         <li>Comandos variados</li>
        </ul>
        <br>

        <li>Comandos para manipular Ficheros y Directorios</li>.
        <br>
        <ul>
         <li>Comando ls</li>
         <li>Comando cd</li>
         <li>Comando pwd</li>
         <li>Comando mkdir</li>
         <li>Comando mv</li>
         <li>Comando cp</li>
         <li>Comando rm</li>
         <li>Comando chown</li>
         <li>Ayuda en el sistema</li>
        </ul>
        <br>
        <li>Comandos para Visualizar, paginar y editar ficheros</li>
        <br>
        <ul>
         <li>Comando cat</li>
         <li>Editor pico</li>
         <li>Editor vi</li>
         <li>Comandos more y less</li>
         <li>Ayuda en el sistema</li>
        </ul>
        <br>

        <li>Comandos para búsquedas de Ficheros y patrones</li>
        <br>
        <ul>
         <li>Comando grep</li>
         <li>Comando find</li>
         <li>Comando locate</li>
         <li>Ayuda en el sistema</li>
        </ul>
        <br>
        <li>Comandos para filtrar ficheros</li>
        <br>
        <ul>
         <li>Comando file</li>
         <li>Comando sort</li>
         <li>Comando uniq</li>
         <li>Comandos tail y head</li>
         <li>Comando wc</li>
         <li>Comando stat</li>
         <li>Ayuda en el sistema</li>
        </ul>
        <br>
        <li>Comandos para compactar y agrupar ficheros</li>
        <br>
        <ul>
         <li>Comandos gzip y gunzip</li>
         <li>Comando tar</li>
         <li>Ayuda en el sistema</li>
        </ul>
        <br>
        <li>Comandos para la counicación entre usuarios</li>
        <br>
        <ul>
         <li>Comando write</li>
         <li>Comando wall</li>
         <li>Comando talk</li>
         <li>Ayuda en el sistema</li>
        </ul>
        <br>
        <li>Comandos para Desconectarse del sistema</li>
       <br>
       <ul>
         <li>Comando exit</li>
         <li>Comando logout</li>
         <li>Ayuda en el sistema</li>
       </ul>
        <li>Comandos para administar usuario y grupos</li>
        <br>
        <ul>
         <li>Comando useradd</li>
         <li>Comando userdel</li>
         <li>Comando passwd</li>
         <li>Comando usermod</li>
         <li>Comando chfn</li>
         <li>Comandos groupadd y groupdel</li>
         <li>Comando groupmod</li>
         <li>Comando gpasswd</li>
         <li>Comando su</li>
         <li>Comando newgrp</li>
         <li>Ayuda en el sistema</li>
        </ul>
        <br>
        <li>Comandos variados</li>
        <br>
        <ul>
         <li>Comando echo</li>
         <li>Comando alias</li>
         <li>Comando type</li>
         <li>Comando tty</li>
         <li>Comando du</li>
         <li>Comando id</li>
         <li>Comando who</li>
         <li>Comando w</li>
         <li>Comando finger</li>
         <li>Comando ping</li>
         <li>Comando ifconfig</li>
         <li>Ayuda en el sistema</li>
        </ul>
        <br>

        <li>Flujo de datos</li>
        <br>
        <p>
         Todos los procesos (programas en ejecución) tienen asociados tres flujos (streams) de datos principales.
        </p>
        <p>Estos son:</p>
        <ul>
         <li>La entrada estándar. Es donde puede tomar los datos que maneja y que no se indican mediante argumentos u opciones. Por defecto se toma a partir del teclado.</li>
         <li>La salida estándar. Es donde un proceso escribe los resultados de su ejecución. Por defecto es la terminal donde se invocó el programa correspondiente.</li>
         <li>La salida de errores. Es donde un proceso escribe los posibles errores durante su ejecución. Por defecto es la terminal donde se invocó el programa correspondiente.</li>
        </ul>
        <br>
        <p>Los flujos de datos se almacenan en descriptores de ficheros que se identifican por
         un número en la forma siguiente:
         </p>
         <ul>
            <li>0: representa la entrada estándar.</li>
            <li>1: representa la salida estándar.</li>
            <li>2: representa la salida de errores.</li>
         </ul>
         <br>
        <li>Redireccionamiento</li>
        <br>
        <ul>
         <li>En bash los flujos de datos se pueden redireccionar libremente hacia distintos ficheros. En esencia este mecanismo consiste en que la salida de un proceso 
            (estándar o de errores) puede escribirse en un fichero en lugar de la terminal asociada, así como la entrada puede tomarse también a partir de un fichero 
            en lugar de utilizar lo escrito mediante el teclado.</li>
            <li>
               Para indicar un redireccionamiento se utilizan los signos de comparación < y >. De esta forma se generan dos tipos de construcción:
            </li>
            <ul>
               <li>[x]>salida: indica el redireccionamiento del flujo de datos x al fichero nombrado salida. De no indicarse x se asumirá la salida estándar del 
                  programa que se haya invocado, o sea, 1.</li>
               <li>[x]'<'entrada: indica el redireccionamiento del contenido del fichero nombrado entrada hacia flujo de datos x. De no indicarse x se asumirá la entrada estándar del comando que se haya invocado, o sea, 0.</li>
            </ul>
        </ul>
        <br>
        <div>
         <img src="imgPrimer/55 1.png" alt="">
         <p>Siempre que se emplee la forma [x]>salida, si el fichero salida existe se sobrescribirá y si no, se creará. Para añadirle algo más a su contenido anterior 
            (append) en lugar de sobrescribirlo, se puede emplear >>.</p>
         <br>
         <img src="imgPrimer/55 2.png" alt="">
        </div>
        <br>
        <li>Tuberias Pipes</li>
        <br>
        <ul>
         <li>son un poderoso mecanismo del shell, permite tomar la salida de un comando y pasársela como entrada a otro.</li>
         <li>Muchos de los comandos mencionados anteriormente, que reciben como argumento un fichero, en caso de omitirse este, utilizan su entrada estándar. 
            Esta entrada puede provenir a su vez de la salida de otros comandos. Lo que permite realizar diversos tipos de filtrado.</li>
         <li>Pueden estar formadas por un número ilimitado de comandos. Estos no se ejecutan secuencialmente, o sea no se espera a que termine uno para ejecutar el 
            siguiente, sino que se va haciendo de forma concurrente. El caracter que se emplea para separar un comando de otro mediante una tubería es |.</li>
        </ul>
        <br>
        <div>
         <img src="imgPrimer/56 1.png" alt="">
        </div>
        <br>
        <li>Entorno de trabajo en bash</li>
        <br>
        <p>
         Un entorno de trabajo en Linux no es más que la configuración que posee un usuario durante su interacción con el sistema y más específicamente con el shell. 
         Las características del entorno para el caso de bash pueden ser la forma en que se muestra el prompt, los alias y funciones definidos y las variables del 
         entorno de forma general, ya que estas definen el comportamiento de muchos programas y comandos. Las facilidades para cambiar el entorno de trabajo dependen
          de las capacidades del shell que se utilice.
        </p>
        <li>Variables del entorno</li>
        <br>
        <ul>
         <li>Almacenan valores que describen las propiedades del entorno de trabajo. Un usuario puede definir sus propias variables o modificar las ya existentes.</li>
         <li>Para asignarle valor a una variable en el shell se emplea el operador = entre el nombre de la variable y el valor asignado (no deben haber espacios intermedios).</li>
         <li>Ejemplo: $ MENSAJE="Hola amigo"</li>
         <li>Para acceder al valor de una variable se emplea el caracter $ seguido por el nombre de la variable. Para imprimir en la terminal el valor de una variable se puede 
            utilizar el comando echo.</li>
        <li>Ejemplo: $ echo $MENSAJE <br> 
         Hola amigo
         </li> 
         <li>Dentro de un shell se pueden ejecutar otros shells que serían hijos del primero (subshells) heredando todo o parte del entorno de trabajo del padre. 
            Para que una variable mantenga su valor en los shells hijos es necesario indicarlo explícitamente mediante el comando export. Ejemplo:</li>
            <ul>
               <li>$ export MENSAJE</li>
            </ul>
         <li>Tanto la asignación del valor como el exportar una variable se pueden hacer a la vez:</li>
         <ul>
            <li>$ export MENSAJE="Hola amigo"</li>
         </ul>
         <li>Para ver las variables del entorno definidas se puede emplear el comando set. Este además se relaciona con las opciones que es otra forma de regir el 
            comportamiento del shell. Las opciones se activan (on) o desactivan (off). Estas se utilizan para indicar propiedades del shell muy específicas por lo que
             no nos vamos a detener en ellas. Si se desea conocer más al respecto se puede hacer $ help set | less.</li>
         <li>Para eliminar el valor de una variable se emplea el comando unset. Ejemplo:</li>
         <ul>
            <li>$ unset MENSAJE</li>
         </ul>
        </ul>
        <br>
        <li>Variables del entorno Bash</li>.
        <br>
        <ul>
         <li>PATH: guarda la secuencia de caminos donde el Shell busca los programas que se intenten ejecutar en la línea de comandos cuando no se utilizan los caminos absolutos. 
            Estos caminos se separan por el caracter “:”
            </li>
         <li>Ejemplo</li>
         <ul>
            <li>$ echo $PATH /bin:/usr/bin:/usr/X11R6/bin:/usr/local/bin
               </li>
         </ul>
         <li>Para añadir un nuevo camino puede hacerse:</li>
         <ul>
            <li>$ export PATH=$PATH: /bin</li>
         </ul>
      <li>USER: contiene el login del usuario actual.</li>
      <li>PAGER: almacena el paginador utilizado por defecto por algunos programas. Por ejemplo, el comando man utiliza esta variable para determinar que paginador 
         empleará, aunque primero chequea otra variable llamada MANPAGER y si esta no tiene valor entonces acude a PAGER, que de no tener valor tampoco, asumirá al 
         less como paginador por defecto. También asociada a man existe la variable MANPATH donde se especifican los caminos de los manuales que despliega man, y 
         LANG para indicar el idioma.</li>
      <li>Ejemplo:</li>
      <ul>
         <li>$ export PAGER=more <br>
            $ man bash
            </li>
      </ul>
   <li>HOME: guarda el directorio base del usuario actual.</li>
   <li>Ejemplo:</li>
      <ul>
         <li>$ echo $HOME <br>
            /home/pepe
            </li>
      </ul>
      <li>
         EDITOR: contiene el editor por defecto del usuario actual. De no tener valor asociado se utiliza vi. En entornos gráficos se pueden indicar editores visuales 
         aunque para ello se prefiere emplear la variable VISUAL. Más adelante veremos un ejemplo del uso de EDITOR.
      </li>
      <li>PS1: almacena la estructura del prompt principal del usuario.</li>
      <li>Ejemplos:</li>
      <ul>
         <li>\d : contiene la fecha del sistema.</li>
         <li>\h : contiene el nombre de la máquina.</li>
         <li>\T : contiene la hora del sistema.</li>
         <li>\u : contiene el login del usuario.</li>
         <li>\w : contiene el nombre completo del directorio de trabajo actual.</li>
         <li>\W : contiene la base del nombre del directorio actual (Ejemplo: para /home/pepe/doc la base es doc).</li>
         <li>\$ : si el ID del usuario es 0 (root) contiene el valor # y sino, $.</li>
         <li>\# : contiene el número del comando actual desde la creación del shell.</li>
      </ul>
      <li>El prompt principal por defecto tiene la forma: "[\u@\h \W]\$ "</li>
      <li>Ejemplo:</li>
      <ul>
         <li>$ export PS1="[\T,\u\#]\$ " <br>
            [14:12:15,pepe 315]$
            </li>
      </ul>
      <li>PS2: guarda el prompt secundario. Este es el que se presenta cuando el shell no puede interpretar lo que se ha escrito hasta el momento. Normalmente el Shell 
         interpreta lo tecleado cuando se pulsa retorno. En caso de que no se halla completado una estructura interpretable bash muestra el prompt secundario, que por 
         defecto es "> ". Para forzar a que bash no interprete algo después del retorno se escribe el caracter ``\'' antes del retorno.</li>
         
        </ul>
        <br>
        <div>
         <img src="imgPrimer/56 2.png" alt="">
        </div>
        <br>
        <ul>
         <li>En este ejemplo se muestra como se emplean las estructuras de control de bash, particularmente para un lazo tipo for. Como ya se ha mencionado existen 
            otras estructuras de las cuales se podrá encontrar información en el manual de bash. Esta secuencia de código permite buscar recursivamente en el 
            directorio /tmp todos los ficheros regulares cuyo tamaño exceda 1M y para cada uno de ellos se ejecutan los comandos stat y rm en forma interactiva. 
            También se imprimen líneas divisorias.</li>
         <li>
            HISTFILE: almacena el nombre absoluto del fichero que contiene el historial de comandos para cada usuario. También existen HISTFILESIZE, HISTCMD e HISTSIZE.
             Esta última indica el tamaño del historial de comandos, que por defecto es de 1000 comandos.
         </li>
      <li>Ejemplo:</li>
         <ul>
            <li>$ echo $HISTFILE <br>
               /home/pepe/.bash_history
               </li>
         </ul>
      <li>PWD: contiene el directorio de trabajo actual. Esta variable la pueden emplear algunos programas para saber desde donde se invocaron.</li>
      <li>SECONDS: almacena la cantidad de segundos transcurridos desde la invocación del shell actual.</li>
        </ul>
        <h4 id="ficheros">Ficheros y perfiles</h4>
        <ul>
         <li>Para cada usuario existen tres ficheros muy importantes que permiten definir en gran medida las características del shell durante la interacción con este. 
            Estos constituyen shells scripts y se conocen como ficheros perfiles o profiles:</li>
            <ol type="a">
               <li>bash_profile: se ejecuta siempre que se abra una nueva sesión en el sistema. Cada vez que un usuario se conecte al sistema se ejecutará el script 
                  .bash_profile, en el caso de que se utilice a bash como shell. Para ser compatible con sus versiones anteriores, bash en caso de que no existiera 
                  .bash_profile, ejecuta .bash_login, o sino, .profile. En este fichero se pueden colocar las asignaciones a las variables del entorno siendo 
                  debidamente exportadas a través de export. También se puede establecer la máscara de permisos usando umask. Existe además un profile general ubicado 
                  en /etc/profile que se ejecuta también siempre que un usuario inicia una sesión en el sistema antes de su profile particular.</li>
               <li>.bash_logout: se ejecuta al terminar una sesión de trabajo. Puede contener comandos para salvar lo hecho durante la sesión.</li>
               <li>.bashrc: se ejecuta siempre que se invoque un nuevo shell. Por lo general en él se colocan las definiciones de funciones y los alias de comandos. 
                  El fichero .bashrc que posee cada usuario por defecto ejecuta primero a /etc/bashrc.</li>
            </ol>
         <li>Cuando se crea un nuevo usuario se le colocan en su directorio base estos tres ficheros cuyos patrones están el directorio /etc/skel.</li>
        </ul>
        <br>
        <li>Ejecución en bash</li>
        <br>
        <ul>
         <li>Existen dos formas de ejecutar un shell script en el bash:</li>
         <ul>
            <li>Invocándolo directamente por su nombre. Para esto el camino al fichero que lo representa debe encontrarse en la variable PATH del entorno, sino será 
               necesario especificar el camino completo del fichero o relativo al directorio actual. El fichero debe además, poseer los permisos de ejecución adecuados. 
               Lo que ocurrirá en este caso es que se creará un shell hijo que será el que realmente ejecute (interprete) al script.</li>
            <li>Utilizando el comando source. De esta forma se ejecutará el script en el shell actual. En este caso no será necesario que el fichero correpondiente posea 
               permisos de ejecución. El comando se puede sustituir por el caracter punto. Por ejemplo, si se modificara el .bash_profile no será necesario, para activar 
               los cambios, desconectarse y conectarse nuevamente al sistema, simplemente se puede hacer:</li>
            
         </ul>
         <li>$ source .bash_profile ó <br>
            $ . .bash_profile
            </li>
            <li>Un ejercicio interesante puede ser hacer un Shell script (editar un fichero) llamado program.sh con la siguiente línea:</li>
            <ul>
               <li>echo $SECONDS</li>
            </ul>
         <li>Ejecutar luego</li>
         <ul>
            <li> $ . program.sh</li>
         </ul>
         <li>Por último asignarle al fichero permisos de ejecución para ejecutarlo de la forma tradicional:</li>
         <ul>
            <li>$ chmod +x program.sh <br>
               $ ./program.sh
               </li>
         </ul>
        </ul>
     </ul>
         <hr>
         <h1 id="links">Espacio de links:</h1>
         <h2>Historia de las computadoras</h2>
         <div>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/mLa6dEu1Y2c" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
            <br>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/Kvk3_MfF7SA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
            <br>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/nITFvyBI72Y" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
            <br>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/qB3Ho7ocXr8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
         </div>
        
         <h2>Computadoras</h2><br>
         <div>
            <a href="https://edu.gcfglobal.org/es/conceptos-basicos-de-programacion/sistema-binario/1/">Conceptos básicos programación</a><br>
         <a href="https://es.wikipedia.org/wiki/Byte">Byte</a><br>
         <a href="https://www.youtube.com/watch?v=c-hyLLdDt7I&ab_channel=EliezerDeLe%C3%B3n">Conversión binario a decimal</a><br>
         <a href="https://www.youtube.com/watch?v=49Y70pV8QFU&ab_channel=EasyTricks">Conversiones de medidas de almacenamiento</a><br>
         </div>
         
       <br>
       <div>
         <a href="https://elcodigoascii.com.ar/">Código ASCII</a><br>
         <a href="https://www.xataka.com/seleccion/como-limpiar-ordenador-dentro-fuera-instrucciones-seguridad-que-necesitas-procedimiento">Mantenimiento Preventivo a ordenador</a><br>
         <a href="https://mpsoftware.com.mx/diferencias-entre-mantenimiento-preventivo-y-correctivo/#:~:text=El%20mantenimiento%20preventivo%20se%20realiza,de%20funcionar%20o%20est%C3%A1n%20da%C3%B1ados">Mantenimiento Preventivo y correctivo</a><br>
         <a href="https://10tipos.com/tipos-de-procesadores/">Tipos de procesadores</a><br>
         <a href="https://www.xataka.com/basics/tipos-memoria-ram-como-elegir-cual-se-adapta-a-que-necesitas">Tipos de RAM</a><br>
         <a href="https://www.xataka.com/basics/que-significa-que-mi-cpu-sea-de-32-o-64-bits-y-cual-es-la-diferencia#:~:text=En%20el%20mundo%20de%20la,los%20%C3%BAnicos%20con%20los%20otros">Procesador 64 o 32 Bits</a><br>
         <a href="https://www.profesionalreview.com/2021/07/18/risc-vs-cisc/#:~:text=Los%20procesadores%20de%20arquitectura%20CISC,Qualcomm%20Snapdragon%20y%20Samsung%20Exynos">Diferencias entre RISC y CISC</a><br>
         <a href="https://drive.google.com/file/d/177Kswbu7NgD2nqr3lbpPpzFw7LlHrwXL/preview">Formulario Mantenimiento</a>
         <a href="https://es.wikipedia.org/wiki/Virtualizaci%C3%B3n">Virtualización</a>
         <a href="https://www.fpgenred.es/VirtualBox/caractersticas_de_virtualbox.html">Características virtualBox</a>
         <a href="https://es.wikipedia.org/wiki/Anexo:Caracter%C3%ADsticas_de_Ubuntu">Características Ubuntu</a>
       </div>
        
    

    

    <footer class="footer">
        <div class="infoper">
            <p>Juan Alberto Ruíz Porras</p>
            <P>5090-23-4471</P>
        </div>
        <div class="logo">
            <a href="https://www.umg.edu.gt">
            <img src="imagenes/logo mariano.png" class="logom">
            </a>
        </div>
    </footer>


</body>
</html>